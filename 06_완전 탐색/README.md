# 완전 탐색
> 모든 경우의 수를 확인해서 최적의 답을 구하는 방법  

## 풀이과정
1. 문제에서 요구하는 완전 탐색이 무엇인지 파악하기
2. 가능한 모든 경우의 수를 만들기
3. 그 중 최적의 해를 찾기

## 어떻게 알아낼까?
1. 입력 크기가 매우 작은 편일까?
2. 문제가 전체 탐색을 요구하나? (정확히 몇 개 있는지 모르겠지만, 여기 중에서 최적해가 나와야 한다)
3. 조건이나 답에서 역으로 실마리를 찾을 수 있나?  
같은 행동을 반복적으로 수행하여 모든 경우의 수를 탐색  
-> 정답을 하나 만들고 특정 규칙으로 동일하게 정답을 만들어낼 수 있는 규칙이 있을까?

## 완전 탐색의 종류와 사용되는 자료구조
### 단순 완전 탐색(brute-force)
시간초과 주의
### 조합과 순열
> 전체에서 몇 가지를 골라서 무엇을 하라  

**선택되는 원소의 순서가 매우 중요하다면**, 순열 
```python
from itertools import permutations
list(permutations(items, k))
list(permutations_with_replacement(items, k)) # 중복순열
``` 
items = 전체 배열, k = 개수  

**가능한 가짓수 자체를 뽑아내는 것이 목적**, 조합
```python
from itertools import combinations
combinations(items, k)
combinations_with_replacement(items, k) # 중복조합
``` 
items = 전체 배열, k = 개수

### 비트마스크
|구분|설명|
|---|---|
|AND (A&B)| A와 B의 비트가 모두 1일 때만 1반환|
|OR (A\|B)| A 또는 B의 비트가 1일 때 1반환|
|NOT (A~B)| 현재 비트를 반전, 0일 때 1, 1일 때 0|
|XOR (A^B)| A 또는 B 둘 중 하나만 1일 때 1 반환|
|SHIFT (A<<B , A>>B)| A비트를 B만큼 자리이동(이동하면서 빈 부분은 0으로 채움)|  
- 메모리 절약 가능
- 단 한번의 계산으로 해당 배열에 원소가 존재하는지 판별할 수 있음
### 재귀
탐색의 방향을 직접 다룰 수 있다. 
### 깊이 우선 탐색(DFS) / 너비 우선 탐색(BFS)
탐색의 방향을 정할 수 있지만, 전체를 조사한다는 것은 변함이 없다.   
- 미로찾기 처럼 이전 선택지와 현재 위치, 그리고 다음 선택지가 중요한 의미가 있을 때  
- 일정한 흐름 자체가 하나의 경우의 수가 될 때  

#### DFS  
스택(stack), 재귀함수 이용  
- 탐색 시 제약 조건을 붙일 때
- 계속 진행하면서 결과가 누적되어야하는 조건이 있을 때
#### BFS
큐(queue), while문 이용  
다음 탐색해야 할 위치를 큐에 저장해서 남은 큐가 전부 없을 때까지 탐색 진행.  
- 최단거리, 최소 비용 등 가장 적은 회수로 답을 찾아내야할 때

## 방문처리/백트랙킹
탐색의 횟수를 줄이자!  

- 먼저 탐색한 부분을 다시 탐색하지 않도록 방문 처리.
- 확인할 필요가 없는 부분은 아예 탐색하지 않기.


